{"version":3,"file":"NewDraggableStage.stories.bc52ca4f.js","sources":["../../src/signals/withSignals.tsx","../../src/utils/aabb.ts","../../src/utils/hooks/useForceRerender.ts","../../src/components/NewDraggableStage/NewDraggableStage.tsx"],"sourcesContent":["import Konva from \"konva\";\nimport { NodeConfig } from \"konva/lib/Node\";\nimport { forwardRef, RefObject, useEffect, useRef } from \"react\";\nimport { KonvaNodeComponent, KonvaNodeEvents } from \"react-konva\";\nimport { RemoveIndex } from \"../utils/type-utils\";\nimport { SignalMap } from \"./types/SignalMap\";\nimport { Signal } from \"./useSignal\";\n\nexport type SignalComponentProps<N extends Konva.Node, C extends NodeConfig> = C & {\n  ref?: RefObject<N>;\n  children?: React.ReactNode;\n  $?: SignalMap<N, C>;\n} & KonvaNodeEvents &\n  React.ClassAttributes<N>;\n\nexport type SignalComponent<N extends Konva.Node, C extends NodeConfig> = (\n  props: RemoveIndex<SignalComponentProps<N, C>>,\n) => JSX.Element;\n\nfunction subscribeToSignals<N extends Konva.Node, C extends NodeConfig>(\n  signals: SignalMap<N, C> | undefined,\n  ref: RefObject<N>,\n) {\n  const addedListenersMap: {\n    [id: string]: number[];\n  } = {};\n\n  const signalsById: {\n    [id: string]: Signal<keyof C[Extract<keyof C, string>]>;\n  } = {};\n\n  const signalIds = [];\n\n  if (signals) {\n    // loop over each signal in our component's signals object\n    // the key is the name of the property on the node that\n    // is listening to the signal\n    for (const key in signals) {\n      if (typeof key === \"string\") {\n        const keyStr = key as keyof N;\n        type SignalType = keyof C[Extract<keyof C, string>];\n\n        const signal = signals[key] as Signal<SignalType>;\n\n        // function to call when changes are broadcast to the signal\n        function onChange(value: SignalType) {\n          if (ref.current) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore :(\n            ref.current[keyStr](value);\n          }\n        }\n\n        const listenerId = signal.addListener(onChange);\n\n        onChange(signal.get());\n\n        const id = signal.id();\n\n        // get the listener map for this signal\n        const listeners = addedListenersMap[id];\n\n        if (!listeners) {\n          // first listener for this signal\n          addedListenersMap[id] = [listenerId];\n          signalsById[id] = signal;\n          signalIds.push(id);\n        } else {\n          // subsequent listeners\n          listeners.push(listenerId);\n        }\n      }\n    }\n  }\n\n  return { addedListenersMap, signalsById, signalIds };\n}\n\nfunction useInternalRef<N extends Konva.Node, C extends NodeConfig>(\n  ref: RefObject<N>,\n  signals?: SignalMap<N, C>,\n) {\n  const internalRef = useRef<N>(null);\n\n  if (!ref && signals) {\n    return internalRef;\n  }\n\n  return ref;\n}\n\nexport function withSignals<N extends Konva.Node, C extends NodeConfig>(\n  Component: KonvaNodeComponent<N, C>,\n): SignalComponent<N, C> {\n  const NodeWithSignals = (props: SignalComponentProps<N, C>, forwardedRef: RefObject<N>) => {\n    const signals = props.$;\n    const ref = useInternalRef(forwardedRef, signals);\n\n    useEffect(() => {\n      if (!ref) {\n        return;\n      }\n\n      // if we have signals, loop through them and register a listener for each one\n      const { addedListenersMap, signalsById, signalIds } = subscribeToSignals<N, C>(signals, ref);\n\n      return () => {\n        for (let i = 0; i < signalIds.length; i++) {\n          const signal = signalsById[signalIds[i]];\n          const listeners = addedListenersMap[signalIds[i]];\n\n          for (let j = 0; j < listeners.length; j++) {\n            signal.removeListenerAt(listeners[j]);\n          }\n        }\n      };\n    }, [ref, signals]);\n\n    return <Component ref={ref} {...props} />;\n  };\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return forwardRef(\n    NodeWithSignals as React.ForwardRefRenderFunction<N, SignalComponentProps<N, C>>,\n  );\n}\n","import Konva from \"konva\";\n\nexport type AABB = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n};\n\n// returns true if the rectangles are touching at all\nexport function aabbOverlap(a: AABB, b: AABB) {\n  return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;\n}\n\n// returns true if b is completely inside a\nexport function aabbContains(a: AABB, b: AABB) {\n  return (\n    a.x <= b.x && a.x + a.width >= b.x + b.width && a.y <= b.y && a.y + a.height >= b.y + b.height\n  );\n}\n\nexport const getNodeAABB = (node: Konva.Node) => ({\n  x: node.x(),\n  y: node.y(),\n  width: node.width(),\n  height: node.height(),\n});\n\nexport const getViewportAABB = (stage: Konva.Stage) => ({\n  x: -stage.x() * (1 / stage.scaleX()),\n  y: -stage.y() * (1 / stage.scaleY()),\n  width: stage.width() * (1 / stage.scaleX()),\n  height: stage.height() * (1 / stage.scaleY()),\n});\n\nexport const getScreenSizeAsAABB = (stage: Konva.Stage) => ({\n  x: 0,\n  y: 0,\n  width: stage.width(),\n  height: stage.height(),\n});\n\nexport function isNodeVisibleInStage(stage: Konva.Stage, node: Konva.Node) {\n  return aabbOverlap(node.getClientRect(), getScreenSizeAsAABB(stage));\n}\n\nexport function lockAABBInAABB(bounds: AABB, node: AABB): AABB {\n  // otherwise, check the size to see if it can even fit inside the bounds\n  const canFit = node.width <= bounds.width && node.height <= bounds.height;\n\n  if (canFit) {\n    const n = { ...node };\n    // if it can fit, return the node rect fitted into the bounds\n    if (n.x < bounds.x) {\n      n.x = bounds.x;\n    } else if (n.x + n.width > bounds.x + bounds.width) {\n      n.x = bounds.x + bounds.width - n.width;\n    }\n\n    if (n.y < bounds.y) {\n      n.y = bounds.y;\n    } else if (n.y + n.height > bounds.y + bounds.height) {\n      n.y = bounds.y + bounds.height - n.height;\n    }\n\n    return n;\n  } else {\n    const center = {\n      x: node.x + node.width / 2,\n      y: node.y + node.height / 2,\n    };\n\n    if (center.x < bounds.x) {\n      center.x = bounds.x;\n    } else if (center.x > bounds.x + bounds.width) {\n      center.x = bounds.x + bounds.width;\n    }\n\n    if (center.y < bounds.y) {\n      center.y = bounds.y;\n    } else if (center.y > bounds.y + bounds.height) {\n      center.y = bounds.y + bounds.height;\n    }\n\n    const newPos = {\n      x: center.x - node.width / 2,\n      y: center.y - node.height / 2,\n    };\n\n    return {\n      x: newPos.x,\n      y: newPos.y,\n      width: node.width,\n      height: node.height,\n    };\n  }\n}\n","import { useState } from \"react\";\n\nexport function useForceRerender() {\n  const [, set] = useState(0);\n  return () => set((n) => n + 1);\n}\n","import Konva from \"konva\";\nimport { IFrame, Vector2d } from \"konva/lib/types\";\nimport { useCallback, useEffect, useMemo, useRef } from \"react\";\nimport { Group, Layer, Rect, Stage as KStage, StageProps } from \"react-konva\";\nimport { useKonvaAnimation } from \"../../animation/useKonvaAnimation\";\nimport { withSignals } from \"../../signals/withSignals\";\nimport { aabbContains, getViewportAABB, lockAABBInAABB } from \"../../utils/aabb\";\nimport { lerp01, lerp2d01 } from \"../../utils/math\";\nimport { useForceRerender } from \"../../utils/hooks/useForceRerender\";\nimport { BoundInnerDraggableRect, DraggableRect, FixedRect } from \"./NewDraggableStageTools\";\n\nconst Stage = withSignals(KStage);\n\nexport type NewDraggableStageProps = StageProps & {\n  onWheel?: (evt: Konva.KonvaEventObject<WheelEvent>) => void;\n};\n\ntype CustomStageAttribs = {\n  isMouseInside?: boolean;\n  targetScale?: number;\n  targetPositionOffset?: Vector2d;\n  isSnappingBack?: boolean;\n  targetPosition?: Vector2d;\n};\n\nlet renders = 0;\n\nconst testRect1 = {\n  x: 100,\n  y: 400,\n  width: 100,\n  height: 100,\n};\n\nconst testRect2 = {\n  x: -200,\n  y: 300,\n  width: 150,\n  height: 150,\n};\n\nconst testRect3 = {\n  x: -50,\n  y: 300,\n  width: 70,\n  height: 70,\n};\n\nfunction FixedGroup({ children }: { children?: React.ReactNode }) {\n  return <Group>{children}</Group>;\n}\n\nexport function NewDraggableStage(props: NewDraggableStageProps) {\n  const stageRef = useRef<Konva.Stage & CustomStageAttribs>(null);\n  const rerender = useForceRerender();\n\n  const ref1 = useRef<Konva.Rect>(null);\n  const ref2 = useRef<Konva.Rect>(null);\n  const ref3 = useRef<Konva.Rect>(null);\n\n  const width = 500;\n  const height = 500;\n\n  renders = renders + 1;\n\n  const onWheelProp = props.onWheel;\n\n  const smoothScaling = true;\n  const smoothSnapBackToBounds = true;\n\n  const viewportBounds = useMemo(\n    () => ({\n      x: 0,\n      y: 0,\n      width: 1000,\n      height: width,\n    }),\n    [],\n  );\n\n  const smoothScalingAnimateFunc = useCallback(\n    (frame?: IFrame) => {\n      if (!frame) return false;\n      // animate scale toward target scale\n      const stage = stageRef.current;\n      if (!stage || !stage.targetPositionOffset) return false;\n\n      if (smoothScaling) {\n        const currentScale = stage.scaleX();\n\n        const t = (frame.timeDiff / 1000) * 20;\n\n        const newScale = lerp01(currentScale, stage.targetScale ?? 1.0, t);\n\n        stage.scaleX(newScale);\n        stage.scaleY(newScale);\n\n        // use the same lerp trick to animate our position, but using the targetPositionOffset,\n        // subtracting until it is zero so that the stage position can still be changed externally\n        const prevPosition = stage.position();\n\n        const targetPosition = {\n          x: prevPosition.x + stage.targetPositionOffset.x,\n          y: prevPosition.y + stage.targetPositionOffset.y,\n        };\n\n        const newPosition = lerp2d01(prevPosition, targetPosition, t);\n\n        const difference = {\n          x: newPosition.x - prevPosition.x,\n          y: newPosition.y - prevPosition.y,\n        };\n\n        stage.position(newPosition);\n        stage.targetPositionOffset = {\n          x: stage.targetPositionOffset.x - difference.x,\n          y: stage.targetPositionOffset.y - difference.y,\n        };\n      }\n    },\n    [smoothScaling],\n  );\n\n  useKonvaAnimation(smoothScalingAnimateFunc, {\n    layer: stageRef?.current?.getLayer() as Konva.Layer,\n  });\n\n  const limitBoundsAnimateFunc = useCallback(\n    (frame?: IFrame) => {\n      if (!frame) return false;\n      // animate scale toward target scale\n      const stage = stageRef.current;\n      if (!stage) return false;\n\n      if (smoothSnapBackToBounds && stage.isSnappingBack && stage.targetPosition) {\n        const position = stage.position();\n        const targetPosition = stage.targetPosition;\n        const newPosition = lerp2d01(position, targetPosition, (frame.timeDiff / 1000) * 14);\n        const movement = {\n          x: newPosition.x - position.x,\n          y: newPosition.y - position.y,\n        };\n\n        stage.position(newPosition);\n\n        if (Math.abs(movement.x) < 0.01 && Math.abs(movement.y) < 0.01) {\n          stage.isSnappingBack = false;\n          stage.targetPosition = undefined;\n        }\n      } else {\n        return false;\n      }\n    },\n    [smoothSnapBackToBounds],\n  );\n\n  useKonvaAnimation(limitBoundsAnimateFunc, {\n    layer: stageRef?.current?.getLayer() as Konva.Layer,\n  });\n\n  const onWheel = useCallback(\n    (e: WheelEvent) => {\n      const stage = stageRef.current;\n      if (stage) {\n        if (stage.isMouseInside) {\n          e.preventDefault();\n\n          // If we're dragging the stage around (like with the middle mouse button),\n          // we don't want to trigger stage zooming.\n          if (stage.isDragging()) return;\n\n          if (e.ctrlKey) {\n            // zooming\n            const prevScale = stage.scaleX();\n            const scaleDelta = Math.exp(-e.deltaY / 100);\n\n            // get pointer position\n            const pointer = stage.getPointerPosition();\n            if (!pointer) return;\n\n            const mousePos = {\n              x: (pointer.x - stage.x()) / prevScale,\n              y: (pointer.y - stage.y()) / prevScale,\n            };\n\n            // apply new scale\n            let newScale = prevScale * scaleDelta;\n\n            // limit zoom\n            newScale = Math.min(Math.max(0.1, newScale), 20);\n\n            const prevPos = stage.position();\n            // apply new position\n            const newPos = {\n              x: pointer.x - mousePos.x * newScale,\n              y: pointer.y - mousePos.y * newScale,\n            };\n\n            if (smoothScaling) {\n              const difference = {\n                x: newPos.x - prevPos.x,\n                y: newPos.y - prevPos.y,\n              };\n              stage.targetPositionOffset = difference;\n\n              stage.targetScale = newScale;\n            } else {\n              stage.scale({ x: newScale, y: newScale });\n              stage.position(newPos);\n            }\n\n            // recheck viewport bounds on zoom\n            const viewportBoundsNeg = {\n              x: -viewportBounds.x,\n              y: -viewportBounds.y,\n              width: viewportBounds.width,\n              height: viewportBounds.height,\n            };\n\n            const cameraPosition = getViewportAABB(stage);\n\n            if (!aabbContains(viewportBoundsNeg, cameraPosition)) {\n              const fixedCameraPosition = lockAABBInAABB(viewportBoundsNeg, cameraPosition);\n              stage.targetPosition = {\n                x: -fixedCameraPosition.x / (1 / stage.scaleX()),\n                y: -fixedCameraPosition.y / (1 / stage.scaleY()),\n              };\n              stage.isSnappingBack = true;\n            }\n          } else {\n            // panning\n            const delta = { x: e.deltaX * -1, y: e.deltaY * -1 };\n\n            const prevPosition = stage.position();\n            const newPosition = {\n              x: prevPosition.x + delta.x,\n              y: prevPosition.y + delta.y,\n            };\n            stage.position(newPosition);\n          }\n\n          if (onWheelProp) {\n            const newKonvaEvent: Konva.KonvaEventObject<WheelEvent> = {\n              type: \"wheel\",\n              target: stage,\n              evt: e,\n              currentTarget: stage,\n              cancelBubble: false,\n            };\n\n            onWheelProp(newKonvaEvent);\n          }\n        }\n      }\n    },\n    [\n      onWheelProp,\n      smoothScaling,\n      viewportBounds.height,\n      viewportBounds.width,\n      viewportBounds.x,\n      viewportBounds.y,\n    ],\n  );\n\n  // Set up the document scroll listener for wheel events\n  useEffect(() => {\n    // We use passive: false so that we can call preventDefault() when we\n    // handle the event on our stage.\n    document.addEventListener(\"wheel\", onWheel, { passive: false });\n\n    return () => {\n      document.removeEventListener(\"wheel\", onWheel);\n    };\n  }, [onWheel]);\n\n  // Mouse enter/leave handlers to handle the isMouseInside attribute.\n  const mouseHandlers = {\n    onMouseEnter: (e: Konva.KonvaEventObject<MouseEvent>) => {\n      const stage = stageRef.current;\n      if (!stage) return;\n\n      stage.isMouseInside = true;\n\n      if (props.onMouseEnter) {\n        props.onMouseEnter(e);\n      }\n    },\n    onMouseLeave: (e: Konva.KonvaEventObject<MouseEvent>) => {\n      const stage = stageRef.current;\n      if (!stage) return;\n\n      stage.isMouseInside = false;\n\n      if (props.onMouseLeave) {\n        props.onMouseLeave(e);\n      }\n    },\n  };\n\n  const dragHandlers = {\n    onDragStart(e: Konva.KonvaEventObject<DragEvent>) {\n      const stage = stageRef.current;\n      if (stage) {\n        stage.isSnappingBack = false;\n        if (e.evt) {\n          // When an object within the stage is dragged, these event handler will be called\n          // multiple times for each event as the event bubbles up to the stage.\n          // As the event bubbles up the parent node, e.currentTarget will store the current node\n          // while e.target will always be the target of the event (the node being dragged).\n\n          // We only care when currentTarget is the stage\n          // so we only process each drag event once.\n          if (e.currentTarget === stage) {\n            // If we're dragging a node that isn't the stage, but we're holding shift,\n            // we switch that drag event over to the stage.\n            if (e.target !== stage) {\n              const shiftKeyDown = e.evt.shiftKey;\n              const middleMouseDown = e.evt.buttons === 4;\n\n              if (shiftKeyDown || middleMouseDown) {\n                e.evt.preventDefault();\n                e.target.stopDrag();\n                e.target = stage;\n                stage.startDrag(e);\n              }\n            }\n          }\n        }\n      }\n\n      if (props.onDragStart) {\n        props.onDragStart(e);\n      }\n    },\n    onDragMove(e: Konva.KonvaEventObject<DragEvent>) {\n      const stage = stageRef.current;\n      const { target, evt } = e;\n      const { movementX, movementY } = evt;\n      if (stage && evt) {\n        const cameraPosition = getViewportAABB(stage);\n      }\n\n      if (props.onDragMove) {\n        props.onDragMove(e);\n      }\n    },\n    onDragEnd(e: Konva.KonvaEventObject<DragEvent>) {\n      const stage = stageRef.current;\n      const { target, evt } = e;\n      if (stage && evt) {\n        if (target === stage && e.currentTarget === stage) {\n          // Check to see if we need to snap the position back to the bounds.\n\n          const cameraPosition = getViewportAABB(stage);\n\n          const vpb = {\n            x: -viewportBounds.x,\n            y: -viewportBounds.y,\n            width: viewportBounds.width,\n            height: viewportBounds.height,\n          };\n\n          if (!aabbContains(vpb, cameraPosition)) {\n            const fixedCameraPosition = lockAABBInAABB(vpb, cameraPosition);\n            stage.targetPosition = {\n              x: -fixedCameraPosition.x / (1 / stage.scaleX()),\n              y: -fixedCameraPosition.y / (1 / stage.scaleY()),\n            };\n            stage.isSnappingBack = true;\n          }\n        }\n      }\n\n      if (props.onDragEnd) {\n        props.onDragEnd(e);\n      }\n    },\n  };\n\n  return (\n    <>\n      <Stage\n        draggable\n        ref={stageRef}\n        width={width}\n        height={height}\n        {...props}\n        {...mouseHandlers}\n        {...dragHandlers}\n      >\n        <Layer>\n          <Rect width={viewportBounds.width} height={viewportBounds.height} fill=\"cornflowerblue\" />\n          <FixedRect x={100} y={100} />\n          <DraggableRect x={180} y={150} />\n          <BoundInnerDraggableRect x={260} y={200} />\n          <Rect ref={ref1} {...testRect1} fill=\"gray\" />\n          <Rect ref={ref2} {...testRect2} fill=\"black\" />\n          <Rect ref={ref3} {...testRect3} fill=\"yellow\" draggable />\n        </Layer>\n      </Stage>\n      <div style={{ width: 500, height: 200, background: \"lightgray\" }}>\n        <code>{`React Renders: ${renders}`}</code>\n        <br />\n        <button\n          onClick={() => {\n            rerender();\n          }}\n        >\n          Trigger One\n        </button>\n      </div>\n    </>\n  );\n}\n"],"names":["ref","onChange","listeners","addedListenersMap","signalsById","signalIds","useRef","useEffect","signal","_jsx","props","forwardRef","useState","KStage","renders","useMemo","width","useCallback","stage","x","y","useKonvaAnimation","e","prevScale","newScale","height","onWheelProp","document","_jsxs","_Fragment","stageRef","mouseHandlers","target","evt","dragHandlers","ref1","testRect1","ref2","testRect2","ref3","testRect3","rerender"],"mappings":"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"}